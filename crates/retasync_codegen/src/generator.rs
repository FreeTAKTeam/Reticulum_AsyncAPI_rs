use std::path::Path;

use anyhow::{anyhow, Context, Result};
use serde::Deserialize;

#[derive(Debug, Clone)]
pub struct CodegenSpec {
    pub commands: Vec<String>,
    pub events: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct AsyncApiDoc {
    #[serde(default, rename = "x-retasync")]
    retasync: RetasyncExtension,
}

#[derive(Debug, Default, Deserialize)]
struct RetasyncExtension {
    #[serde(default)]
    operations: OperationsExtension,
}

#[derive(Debug, Default, Deserialize)]
struct OperationsExtension {
    #[serde(default)]
    commands: Vec<String>,
    #[serde(default)]
    events: Vec<String>,
}

pub fn generate_contracts(input_path: &Path, output_path: &Path) -> Result<()> {
    let source = std::fs::read_to_string(input_path)
        .with_context(|| format!("failed reading {}", input_path.display()))?;
    let rendered = render_contracts_module(&source)?;

    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent).with_context(|| {
            format!(
                "failed creating destination directory {}",
                parent.display()
            )
        })?;
    }

    std::fs::write(output_path, rendered)
        .with_context(|| format!("failed writing {}", output_path.display()))
}

pub fn render_contracts_module(asyncapi_yaml: &str) -> Result<String> {
    let spec = load_spec(asyncapi_yaml)?;
    Ok(render_spec(&spec))
}

fn load_spec(source: &str) -> Result<CodegenSpec> {
    let doc: AsyncApiDoc = serde_yaml::from_str(source).context("failed parsing AsyncAPI YAML")?;

    if doc.retasync.operations.commands.is_empty() {
        return Err(anyhow!(
            "x-retasync.operations.commands must include at least one operation"
        ));
    }

    Ok(CodegenSpec {
        commands: doc.retasync.operations.commands,
        events: doc.retasync.operations.events,
    })
}

fn render_spec(spec: &CodegenSpec) -> String {
    let mut out = String::new();
    out.push_str("// Generated by cargo xtask codegen. Do not edit manually.\n\n");
    out.push_str("use async_trait::async_trait;\n");
    out.push_str("use serde::{Deserialize, Serialize};\n\n");

    out.push_str("#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n");
    out.push_str("#[serde(rename_all = \"snake_case\")]\n");
    out.push_str("pub enum CommandOperation {\n");
    for command in &spec.commands {
        out.push_str("    ");
        out.push_str(&to_pascal_case(command));
        out.push_str(",\n");
    }
    out.push_str("}\n\n");

    out.push_str("#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n");
    out.push_str("#[serde(rename_all = \"snake_case\")]\n");
    out.push_str("pub enum EventOperation {\n");
    for event in &spec.events {
        out.push_str("    ");
        out.push_str(&to_pascal_case(event));
        out.push_str(",\n");
    }
    if spec.events.is_empty() {
        out.push_str("    NoneDefined,\n");
    }
    out.push_str("}\n\n");

    out.push_str("#[async_trait]\n");
    out.push_str("pub trait CommandDispatch {\n");
    for command in &spec.commands {
        let fn_name = to_snake_case(command);
        let rust_ty = format!("{}Payload", to_pascal_case(command));
        out.push_str("    async fn ");
        out.push_str(&fn_name);
        out.push_str("(&self, payload: ");
        out.push_str(&rust_ty);
        out.push_str(") -> anyhow::Result<serde_json::Value>;\n");
    }
    out.push_str("}\n\n");

    for command in &spec.commands {
        let rust_ty = format!("{}Payload", to_pascal_case(command));
        out.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        out.push_str("pub struct ");
        out.push_str(&rust_ty);
        out.push_str(" {\n");
        out.push_str("    pub body: serde_json::Value,\n");
        out.push_str("}\n\n");
    }

    out.push_str("#[async_trait]\n");
    out.push_str("pub trait MeshClientBackend {\n");
    out.push_str("    async fn send_command(&self, operation: &str, payload: serde_json::Value) -> anyhow::Result<serde_json::Value>;\n");
    out.push_str("}\n\n");

    out.push_str("pub struct MeshClient<B> {\n");
    out.push_str("    backend: B,\n");
    out.push_str("}\n\n");

    out.push_str("impl<B> MeshClient<B> {\n");
    out.push_str("    pub fn new(backend: B) -> Self {\n");
    out.push_str("        Self { backend }\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    out.push_str("impl<B> MeshClient<B>\n");
    out.push_str("where\n");
    out.push_str("    B: MeshClientBackend + Send + Sync,\n");
    out.push_str("{\n");
    for command in &spec.commands {
        let fn_name = format!("call_{}", to_snake_case(command));
        let rust_ty = format!("{}Payload", to_pascal_case(command));
        out.push_str("    pub async fn ");
        out.push_str(&fn_name);
        out.push_str("(&self, payload: ");
        out.push_str(&rust_ty);
        out.push_str(") -> anyhow::Result<serde_json::Value> {\n");
        out.push_str("        self.backend.send_command(\"");
        out.push_str(command);
        out.push_str("\", payload.body).await\n");
        out.push_str("    }\n\n");
    }
    out.push_str("}\n");

    out
}

fn to_pascal_case(name: &str) -> String {
    name
        .split(['.', '_', '-', '/'])
        .filter(|segment| !segment.is_empty())
        .map(|segment| {
            let mut chars = segment.chars();
            match chars.next() {
                Some(first) => {
                    let mut item = String::new();
                    item.push(first.to_ascii_uppercase());
                    item.push_str(chars.as_str());
                    item
                }
                None => String::new(),
            }
        })
        .collect::<String>()
}

fn to_snake_case(name: &str) -> String {
    name
        .chars()
        .map(|c| match c {
            '.' | '-' | '/' => '_',
            other => other.to_ascii_lowercase(),
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::render_contracts_module;

    #[test]
    fn renders_commands_and_events() {
        let source = r#"
asyncapi: "3.0.0"
x-retasync:
  operations:
    commands:
      - emergency_action_message.create
    events:
      - emergency_action_message.created
"#;

        let rendered = render_contracts_module(source).expect("rendered");
        assert!(rendered.contains("EmergencyActionMessageCreate"));
        assert!(rendered.contains("EmergencyActionMessageCreated"));
        assert!(rendered.contains("trait CommandDispatch"));
    }
}
